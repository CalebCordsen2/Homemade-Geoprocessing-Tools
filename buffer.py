"""
Author: Caleb Cordsen
Date: 4/8/2023

Description: This file contains the functions that help make the buffer function work!
"""
import arcpy
from arcpy import env
import math
import numpy as np
import os

def PointsBuffer(returnDir,inputFile, outputName, buffSize, pointsForBuff = 87):
    '''
    Parameters
    ----------
    returnDir : This should be a string representing a file path.
        This should be a string representing a file path to the directory/folder you wish to save
        your created buffer file to.
    inputFile : This should be a string representing a file path.
        This should be a string representing a file path that points to a valid shape file made up 
        of points.
    outputName : This should be a string representing a file name and extension.
        This should be a string representing a file name and extension. This will be 
        the name of the outputted buffer shape file.
    buffSize : This should be a number.
        This should be a number representing how big you want the buffer to be. Currently this
        function is limited to only doing buffers of the same unit that the inputFile exists in.
    pointsForBuff : This should be an interger., optional
        This should be an integer representing how many points you want the buffer
        to be composed of. Beware the less number of points you make the buffer of the less circular
        the buffer will be I.E inputting 4 here will result in a square/rhombus buffer. The default
        value is 87 since this is around the number of points Arc uses to make their buffers.

    Returns
    -------
    None.
    
    Logic: This function will first create an empty list called centerCoordLst. This list will
    consist of tuples of (x,y) pairs representing all the points in the inputFile. Then it will
    get the input files coordinate system and store it in inputCoordinateSystem. Then it briefly
    checks to make sure that the output name and directory that you have inputted does not already exist.
    If it does this function deletes it to make room for a new file. Then it opens a search cursor
    on the inputfile, extracting the x and y coordinates using SHAPE@X and SHAPE@Y. It goes through
    each point in the inputFile and appends their (x,y) pair to centerCoordLst. Then it makes
    a new shape file based on inputted returnDir and outputName, making it of type polygon and giving
    it the same coordinate system as the input file. Then it opens an insert cursor on the newly
    made shape file accessing its geometry property. Then with that insert cursor open, the function
    enters a loop iterating through the previously made centerCoordLst. For each (x,y) pair in this list,
    we declare a new list, circleCoordPoints that will contain all the arc points that make up the buffer.
    To determine the points we enter another loop using np.linspace. np.linspace takes in a start value,
    a stop value, and how many divisions you want. In this functions case, it goes from 0 to 360 since
    this represents the range of angular values that make up a circle. Then it takes in the inputted
    number of points to construct the buffer, subsequently dividing 0 to 360 up into even intervals, where
    the number of intervals is the number of points. The function includes the optional keyword in
    np.linspace endpoint=False since we do not want to include 360 as one of the points np.linspace
    generates since 0 and 360 are the same in a circle. Np.linspace returns an array of the
    point that divide up 0,360 aka angles. Our function
    loops directly through this. Now it calculates newX and newY values to begin building the circle.
    To do this it exploits the unit circle in the following way: A unit circle is a circle of radius 
    one and center point at (0,0). The points that make up the unit circle can be generated by
    doing (cos(radianMeasure),sin(radianMeasure)) aka the (x,y) points that make up the unit circle
    can be found by doing x = cos(radianMeasure) and y = sin(radianMeasure) So for example,
    one of the points on the unit circle is (0,1) and this can be generated by doing (cos(pi/2),sin(pi/2))
    math.cos and math.sin operate in radians so we will convert our degrees from np.linspace
    to radians by doing math.radians(angle). Then we can feed that number to math.cos() and
    math.sin() to get our X and Y respectively. However, this X and Y is that on a unit circle which
    has a radius of 1 and center point of (0,0). To transform this to a buffer where radius = buffSize
    and center point of (xCenterCoord,yCenterCoord) we multiple the math.cos() and math.sin()
    operations by buffSize then add xCenterCoord to x and yCenterCoord to y. This will transform our
    points to properly build our buffer. Consider why this works: Our right most point in a unit circle
    is (1,0). If we want a cirlce with radius = 4 and center point (5,7) our right most point should
    be at (9,7) aka 4 units to the right of the center. If (1,0) is determined via (cos(0),sin(0)) 
    then to transform it to (9,7) just adding 5 to the x and 7 to the y is insufficient since then we
    get (6,7). To replicate both the center point and radius we need to multiple the cos and sin values
    by the radius before adding the center point. This results in (9,7). So we apply this transformation
    generally to form all the buffer points.
    Then we add this newly generated point to our CircleCoordPoints. Once
    all the points have been generated stuff them into an arcpy array, and then put that arcpy array
    into an arcpy polygon and then insert that arcpy polygon as a new row in the outputfile. This
    process repeats for every point in the inputed shape file.
    '''
    try:
        centerCoordLst = []
        inputCoordinateSystem = arcpy.Describe(inputFile).spatialReference
        
        if (os.path.exists(os.path.join(returnDir,outputName))):
            arcpy.management.Delete(os.path.join(returnDir,outputName))
            
        with arcpy.da.SearchCursor(inputFile,['SHAPE@X','SHAPE@Y']) as sCursor:
            for row in sCursor:
                centerCoordLst.append((row[0],row[1]))
        
        
        arcpy.CreateFeatureclass_management(returnDir, outputName,'POLYGON',spatial_reference=inputCoordinateSystem)
        
        
        with arcpy.da.InsertCursor(os.path.join(returnDir,outputName), ['SHAPE@']) as iCursor:
            for xCenterCoord,yCenterCoord in centerCoordLst:
                circleCoordPoints = []
                for angle in np.linspace(0,360,pointsForBuff,endpoint=False):
                    newX = buffSize*math.cos(math.radians(angle))+xCenterCoord
                    newY = buffSize*math.sin(math.radians(angle))+yCenterCoord
                    circleCoordPoints.append(arcpy.Point(newX,newY))
        
                circlePointArray = arcpy.Array(circleCoordPoints)
                bufferPolygon = arcpy.Polygon(circlePointArray)
                iCursor.insertRow([bufferPolygon])
        return "The buffer was successful!"
    except:
        return "The buffer was unsuccessful. Sorry!"
            
def lineBuffer(returnDir,inputFile, outputName, buffSize):
    try:
        inputCoordinateSystem = arcpy.Describe(inputFile).spatialReference
        
        if (os.path.exists(os.path.join(returnDir,outputName))):
            arcpy.management.Delete(os.path.join(returnDir,outputName))
        if (os.path.exists(os.path.join(returnDir,'intermediate.shp'))):
            arcpy.management.Delete(os.path.join(returnDir,'intermediate.shp'))
        arcpy.CreateFeatureclass_management(returnDir, 'intermediate.shp','POLYGON',spatial_reference=inputCoordinateSystem)
        
        with arcpy.da.InsertCursor(os.path.join(returnDir,'intermediate.shp'), ['SHAPE@']) as iCursor:
            with arcpy.da.SearchCursor(inputFile,['SHAPE@']) as SearchCursor:
                for row in SearchCursor:
                    # Access the row containing line information
                    pLine = row[0]
                    # Get the Array containing the lines points by doing .getPart(0)
                    pLineArray = pLine.getPart(0)
                    # Some lines may have more than two points. Since they are stored in an array
                    # Just loop through the array accessing individual elt points each time
                    prevPoint = None
                    for point in pLineArray:
                        circleCoordPoints = []
                        for angle in np.linspace(0,360,87,endpoint=False):
                            newX = buffSize*math.cos(math.radians(angle))+point.X
                            newY = buffSize*math.sin(math.radians(angle))+point.Y
                            circleCoordPoints.append(arcpy.Point(newX,newY))
                        circlePointArray = arcpy.Array(circleCoordPoints)
                        bufferPolygon = arcpy.Polygon(circlePointArray)
                        iCursor.insertRow([bufferPolygon])
                        if(prevPoint!=None):
                            dx = point.X - prevPoint.X
                            dy = point.Y - prevPoint.Y
                            D = math.sqrt(dx*dx + dy*dy)
                            dx = buffSize * dx / D
                            dy = buffSize*dy/D
                            rectangleCoords = []
                            rectangleCoords.append(arcpy.Point(prevPoint.X-dy,prevPoint.Y+dx))
                            rectangleCoords.append(arcpy.Point(prevPoint.X+dy,prevPoint.Y-dx))
                            rectangleCoords.append(arcpy.Point(point.X+dy,point.Y-dx))
                            rectangleCoords.append(arcpy.Point(point.X-dy,point.Y+dx))
                            rectangleArray = arcpy.Array(rectangleCoords)
                            rectanglePolygon = arcpy.Polygon(rectangleArray)
                            iCursor.insertRow([rectanglePolygon])
                        prevPoint = point
                
        arcpy.management.Dissolve(os.path.join(returnDir,'intermediate.shp'),os.path.join(returnDir,outputName))
        return "The buffer was successful!"
    except:
        return "The buffer was unsuccessful. Sorry!"
  
def polygonBuffer(returnDir,inputFile, outputName, buffSize):
    try:
        inputCoordinateSystem = arcpy.Describe(inputFile).spatialReference
        
        if (os.path.exists(os.path.join(returnDir,outputName))):
            arcpy.management.Delete(os.path.join(returnDir,outputName))
        if (os.path.exists(os.path.join(returnDir,'intermediate.shp'))):
            arcpy.management.Delete(os.path.join(returnDir,'intermediate.shp'))
        arcpy.CreateFeatureclass_management(returnDir, 'intermediate.shp','POLYGON',spatial_reference=inputCoordinateSystem)
        
        with arcpy.da.InsertCursor(os.path.join(returnDir,'intermediate.shp'), ['SHAPE@']) as iCursor:
            with arcpy.da.SearchCursor(inputFile,['SHAPE@']) as SearchCursor:
                for row in SearchCursor:
                    # Access the row containing line information
                    pLine = row[0].boundary()
                    iCursor.insertRow([row[0]])
                    # Get the Array containing the lines points by doing .getPart(0)
                    pLineArray = pLine.getPart(0)
                    # Some lines may have more than two points. Since they are stored in an array
                    # Just loop through the array accessing individual elt points each time
                    prevPoint = None
                    for point in pLineArray:
                        circleCoordPoints = []
                        for angle in np.linspace(0,360,87,endpoint=False):
                            newX = buffSize*math.cos(math.radians(angle))+point.X
                            newY = buffSize*math.sin(math.radians(angle))+point.Y
                            circleCoordPoints.append(arcpy.Point(newX,newY))
                        circlePointArray = arcpy.Array(circleCoordPoints)
                        bufferPolygon = arcpy.Polygon(circlePointArray)
                        iCursor.insertRow([bufferPolygon])
                        if(prevPoint!=None):
                            dx = point.X - prevPoint.X
                            dy = point.Y - prevPoint.Y
                            D = math.sqrt(dx*dx + dy*dy)
                            dx = buffSize * dx / D
                            dy = buffSize*dy/D
                            rectangleCoords = []
                            rectangleCoords.append(arcpy.Point(prevPoint.X-dy,prevPoint.Y+dx))
                            rectangleCoords.append(arcpy.Point(prevPoint.X+dy,prevPoint.Y-dx))
                            rectangleCoords.append(arcpy.Point(point.X+dy,point.Y-dx))
                            rectangleCoords.append(arcpy.Point(point.X-dy,point.Y+dx))
                            rectangleArray = arcpy.Array(rectangleCoords)
                            rectanglePolygon = arcpy.Polygon(rectangleArray)
                            iCursor.insertRow([rectanglePolygon])
                        prevPoint = point
                
        # arcpy.management.Dissolve(os.path.join(returnDir,'intermediate.shp'),os.path.join(returnDir,outputName))
        return "The buffer was successful!"
    except:
        return "The buffer was unsuccessful. Sorry!"
    
    
#print(polygonBuffer(r"C:/Users/caleb/GEOG 4303/CordsenCalebFinalProject/Test Results",r"C:/Users/caleb/GEOG 4303/CordsenCalebFinalProject/Test Data/boulder_city.shp","test.shp",50))    
    
def bufferMain(returnDir,inputFile, outputName, buffSize):
    geoType = arcpy.Describe(inputFile).shapeType.upper()
    if(geoType=="POINT"):
        return PointsBuffer(returnDir,inputFile,outputName,buffSize)
    elif(geoType=="POLYLINE"):
        return lineBuffer(returnDir,inputFile,outputName,buffSize)
    elif(geoType=="POLYGON"):
        return polygonBuffer(returnDir,inputFile,outputName,buffSize)
    else:
        return "Sorry that kind of buffer is not yet available!"